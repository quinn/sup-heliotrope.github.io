<!-- MHonArc v2.6.18 -->
<!--X-Subject: [sup&#45;devel] [PATCH] Converted crypto to use the gpgme gem -->
<!--X-From-R13: Vnzvfu R <qzvfuqNtznvy.pbz> -->
<!--X-Date: Sat, 6 Nov 2010 14:12:36 &#45;0700 (PDT) -->
<!--X-Message-Id: AANLkTinrSAheJb2F4Xw9AmgXcGLxeQh0_MEnuTSATye_@mail.gmail.com -->
<!--X-Content-Type: multipart/mixed -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>[sup-devel] [PATCH] Converted crypto to use the gpgme gem</title>
<link rev="made" href="mailto:dmishd@gmail.com">
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00723.html">Date Prev</a>][<a href="msg00766.html">Date Next</a>][<a href="msg00620.html">Thread Prev</a>][<a href="msg00766.html">Thread Next</a>][<a href="maillist.html#00738">Date Index</a>][<a href="threads.html#00738">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>[sup-devel] [PATCH] Converted crypto to use the gpgme gem</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <a href="mailto:sup-devel%40rubyforge.org">sup-devel@rubyforge.org</a></li>
<li><em>Subject</em>: [sup-devel] [PATCH] Converted crypto to use the gpgme gem</li>
<li><em>From</em>: Hamish D &lt;<a href="mailto:dmishd%40gmail.com">dmishd@gmail.com</a>&gt;</li>
<li><em>Date</em>: Sat, 6 Nov 2010 20:08:01 +0000</li>
<li><em>Authentication-results</em>: mx.google.com; spf=pass (google.com: domain of <a href="mailto:sup-devel-bounces%40rubyforge.org">sup-devel-bounces@rubyforge.org</a> designates 205.234.109.19 as permitted sender) smtp.mail=<a href="mailto:sup-devel-bounces%40rubyforge.org">sup-devel-bounces@rubyforge.org</a>; dkim=neutral (body hash did not verify) header.i=@gmail.com</li>
<li><em>Delivered-to</em>: <a href="mailto:eg%40gaute.vetsj.com">eg@gaute.vetsj.com</a></li>
<li><em>Delivered-to</em>: <a href="mailto:sup-devel%40rubyforge.org">sup-devel@rubyforge.org</a></li>
<li><em>Dkim-signature</em>: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=gamma;	h=domainkey-signature:mime-version:received:received:date:message-id	:subject:from:to:content-type;	bh=x7FJ3NshsGIxlOa5vbBGTTNzLAEEEfIRvtJARvsBOxs=;	b=clSZMcD2qCfCmDGfBFVOGJtSzz1Oce4gbolq6haWn1iPj8Bu3ZNS8/wOXDqRErNgqX	2RJW2PnoeizgcMWJyLla7GOPfx1O2j2tomcE1m6bxehiUhB0xtbte0qUycUoYnk0cVIt	xhhRtwZPsQA7TNSgE9GSb1YHwQBFhOUF6Aae8=</li>
<li><em>Domainkey-signature</em>: a=rsa-sha1; c=nofws; d=gmail.com; s=gamma;	h=mime-version:date:message-id:subject:from:to:content-type;	b=rHDq9ZmToKt9Yi1TRlI4QVHyOCXeMGmfeZrutQDZWSQkNgw93Fl4lGhfY97k9cy25j	tyaK+9xuuG7CE/cvKtx9B/8naeEXRdbAdqJo9rbRgmOCaYutbe+4H71ohtBh84OWCilX	bjCHupbICtKEqVJ7eI/+lEC6gaKXDmZg7Hvrg=</li>
<li><em>List-archive</em>: &lt;<a href="http://rubyforge.org/pipermail/sup-devel">http://rubyforge.org/pipermail/sup-devel</a>&gt;</li>
<li><em>List-help</em>: &lt;<a href="mailto:sup-devel-request@rubyforge.org?subject=help">mailto:sup-devel-request@rubyforge.org?subject=help</a>&gt;</li>
<li><em>List-id</em>: Sup developer discussion &lt;sup-devel.rubyforge.org&gt;</li>
<li><em>List-post</em>: &lt;<a href="mailto:sup-devel@rubyforge.org">mailto:sup-devel@rubyforge.org</a>&gt;</li>
<li><em>List-subscribe</em>: &lt;<a href="http://rubyforge.org/mailman/listinfo/sup-devel">http://rubyforge.org/mailman/listinfo/sup-devel</a>&gt;,	&lt;<a href="mailto:sup-devel-request@rubyforge.org?subject=subscribe">mailto:sup-devel-request@rubyforge.org?subject=subscribe</a>&gt;</li>
<li><em>List-unsubscribe</em>: &lt;<a href="http://rubyforge.org/mailman/options/sup-devel">http://rubyforge.org/mailman/options/sup-devel</a>&gt;,	&lt;<a href="mailto:sup-devel-request@rubyforge.org?subject=unsubscribe">mailto:sup-devel-request@rubyforge.org?subject=unsubscribe</a>&gt;</li>
<li><em>Reply-to</em>: Sup developer discussion &lt;<a href="mailto:sup-devel%40rubyforge.org">sup-devel@rubyforge.org</a>&gt;</li>
<li><em>Sender</em>: <a href="mailto:sup-devel-bounces%40rubyforge.org">sup-devel-bounces@rubyforge.org</a></li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>I often find that loading long threads of encrypted messages (I have
several of over 10 messages and one of nearly 40) leads to lots of
flickering as the console replaces sup, sup comes back, the console
comes back again ... It is also very slow, and involves writing
decrypted messages to disk (if only temporarily) which could be a
security hole. So I've looked about and found the gpgme gem which
provides an API to use, and allows decryption entirely in memory.

So I've rewritten lib/sup/crypto.rb to use gpgme. The functionality is
pretty much the same. Things I'm aware of that are different:

* we can't set the signature algorithm, so we have to use whatever is
set in the user's preferences
* the gpg-args hook has been replaced by the gpg-options hook

Other than that I think it is the same, although it took some work to
get the signature output to be the same. The other main difference is
that it's much faster and nicer now :)

It could do with some testing - I don't have much in the way of
messages that cause gpg to complain, so if you do, please try opening
those messages with this code and see if the behaviour is reasonable -
no crashes, given messages about why your message was bad etc.

Also I guess I should ask if people are happy to use this gem. Is it
hard to use on Macs? I guess I could rewrite this patch so it falls
back to the gpg binary if gpgme is not available ...

To install this patch on Debian/Ubuntu you can either

* apt-get install libgpgme-ruby
* apt-get install libgpgme11-dev; gem install gpgme

Hamish Downer
</pre><pre>From 52441d1eb749bb1e3b5026e42a334e9c8f455833 Mon Sep 17 00:00:00 2001
From: Hamish Downer &lt;dmishd@gmail.com&gt;
Date: Fri, 5 Nov 2010 22:30:55 +0000
Subject: [PATCH] Converted crypto to use the gpgme gem

---
 bin/sup           |   11 +++
 lib/sup/crypto.rb |  231 ++++++++++++++++++++++++++++++-----------------------
 2 files changed, 141 insertions(+), 101 deletions(-)

diff --git a/bin/sup b/bin/sup
index 10be161..ad7a0d1 100755
--- a/bin/sup
+++ b/bin/sup
@@ -10,6 +10,13 @@ rescue LoadError
   no_ncursesw = true
 end
 
+no_gpgme = false
+begin
+  require 'gpgme'
+rescue LoadError
+  no_gpgme = true
+end
+
 require 'fileutils'
 require 'trollop'
 require &quot;sup&quot;; Redwood::check_library_version_against &quot;git&quot;
@@ -23,6 +30,10 @@ if no_ncursesw
   info &quot;No 'ncursesw' gem detected. Install it for wide character support.&quot;
 end
 
+if no_gpgme
+  info &quot;No 'gpgme' gem detected. Install it for email encryption, decryption and signatures.&quot;
+end
+
 $opts = Trollop::options do
   version &quot;sup v#{Redwood::VERSION}&quot;
   banner &lt;&lt;EOS
diff --git a/lib/sup/crypto.rb b/lib/sup/crypto.rb
index c7b57c1..9d21ea0 100644
--- a/lib/sup/crypto.rb
+++ b/lib/sup/crypto.rb
@@ -1,3 +1,8 @@
+begin
+  require 'gpgme'
+rescue LoadError
+end
+
 module Redwood
 
 class CryptoManager
@@ -11,76 +16,79 @@ class CryptoManager
     [:encrypt, &quot;Encrypt only&quot;]
   )
 
-  HookManager.register &quot;gpg-args&quot;, &lt;&lt;EOS
-Runs before gpg is executed, allowing you to modify the arguments (most
+  HookManager.register &quot;gpg-options&quot;, &lt;&lt;EOS
+Runs before gpg is called, allowing you to modify the options (most
 likely you would want to add something to certain commands, like
---trust-model always to signing/encrypting a message, but who knows).
+{:always_trust =&gt; true} to encrypting a message, but who knows).
 
 Variables:
-args: arguments for running GPG
+operation: what operation will be done (&quot;sign&quot;, &quot;encrypt&quot;, &quot;decrypt&quot; or &quot;verify&quot;)
+options: a dictionary of values to be passed to GPGME
 
-Return value: the arguments for running GPG
+Return value: a dictionary to be passed to GPGME
 EOS
 
   def initialize
     @mutex = Mutex.new
 
-    bin = `which gpg`.chomp
-    @cmd = case bin
-    when /\S/
-      debug &quot;crypto: detected gpg binary in #{bin}&quot;
-      &quot;#{bin} --quiet --batch --no-verbose --logger-fd 1 --use-agent&quot;
-    else
-      debug &quot;crypto: no gpg binary detected&quot;
-      nil
+    # test if the gpgme gem is available
+    @gpgme_present = true
+    begin
+    GPGME.check_version({:protocol =&gt; GPGME::PROTOCOL_OpenPGP})
+    rescue NameError, GPGME::Error
+      @gpgme_present = false
     end
   end
 
-  def have_crypto?; !@cmd.nil? end
+  def have_crypto?; @gpgme_present end
 
   def sign from, to, payload
-    payload_fn = Tempfile.new &quot;redwood.payload&quot;
-    payload_fn.write format_payload(payload)
-    payload_fn.close
+    return unknown_status(cant_find_gpgme) unless @gpgme_present
 
-    sig_fn = Tempfile.new &quot;redwood.signature&quot;; sig_fn.close
+    gpg_opts = {:protocol =&gt; GPGME::PROTOCOL_OpenPGP, :armor =&gt; true, :textmode =&gt; true}
+    gpg_opts.merge(gen_sign_user_opts(from))
+    gpg_opts = HookManager.run(&quot;gpg-options&quot;, 
+                               {:operation =&gt; &quot;sign&quot;, :options =&gt; gpg_opts}) || gpg_opts
 
-    sign_user_opts = gen_sign_user_opts from
-    message = run_gpg &quot;--output #{sig_fn.path} --yes --armor --detach-sign --textmode --digest-algo sha256 #{sign_user_opts} #{payload_fn.path}&quot;, :interactive =&gt; true
-    unless $?.success?
-      info &quot;Error while running gpg: #{message}&quot;
+    begin
+      sig = GPGME.detach_sign(format_payload(payload), gpg_opts)
+    rescue GPGME::Error =&gt; exc
+      info &quot;Error while running gpg: #{exc.message}&quot;
       raise Error, &quot;GPG command failed. See log for details.&quot;
     end
 
     envelope = RMail::Message.new
-    envelope.header[&quot;Content-Type&quot;] = 'multipart/signed; protocol=application/pgp-signature; micalg=pgp-sha256'
+    envelope.header[&quot;Content-Type&quot;] = 'multipart/signed; protocol=application/pgp-signature'
 
     envelope.add_part payload
-    signature = RMail::Message.make_attachment IO.read(sig_fn.path), &quot;application/pgp-signature&quot;, nil, &quot;signature.asc&quot;
+    signature = RMail::Message.make_attachment sig, &quot;application/pgp-signature&quot;, nil, &quot;signature.asc&quot;
     envelope.add_part signature
     envelope
   end
 
   def encrypt from, to, payload, sign=false
-    payload_fn = Tempfile.new &quot;redwood.payload&quot;
-    payload_fn.write format_payload(payload)
-    payload_fn.close
-
-    encrypted_fn = Tempfile.new &quot;redwood.encrypted&quot;; encrypted_fn.close
-
-    recipient_opts = (to + [ from ] ).map { |r| &quot;--recipient '&lt;#{r}&gt;'&quot; }.join(&quot; &quot;)
-    sign_opts = &quot;&quot;
-    sign_opts = &quot;--sign --digest-algo sha256 &quot; + gen_sign_user_opts(from) if sign
-    message = run_gpg &quot;--output #{encrypted_fn.path} --yes --armor --encrypt --textmode #{sign_opts} #{recipient_opts} #{payload_fn.path}&quot;, :interactive =&gt; true
-    unless $?.success?
-      info &quot;Error while running gpg: #{message}&quot;
+    return unknown_status(cant_find_gpgme) unless @gpgme_present
+
+    gpg_opts = {:protocol =&gt; GPGME::PROTOCOL_OpenPGP, :armor =&gt; true, :textmode =&gt; true}
+    if sign
+      gpg_opts.merge(gen_sign_user_opts(from)) 
+      gpg_opts.merge({:sign =&gt; true})
+    end
+    gpg_opts = HookManager.run(&quot;gpg-options&quot;, 
+                               {:operation =&gt; &quot;encrypt&quot;, :options =&gt; gpg_opts}) || gpg_opts
+    recipients = to + [from]
+
+    begin
+      cipher = GPGME.encrypt(recipients, format_payload(payload), gpg_opts)
+    rescue GPGME::Error =&gt; exc
+      info &quot;Error while running gpg: #{exc.message}&quot;
       raise Error, &quot;GPG command failed. See log for details.&quot;
     end
 
     encrypted_payload = RMail::Message.new
     encrypted_payload.header[&quot;Content-Type&quot;] = &quot;application/octet-stream&quot;
     encrypted_payload.header[&quot;Content-Disposition&quot;] = 'inline; filename=&quot;msg.asc&quot;'
-    encrypted_payload.body = IO.read(encrypted_fn.path)
+    encrypted_payload.body = cipher
 
     control = RMail::Message.new
     control.header[&quot;Content-Type&quot;] = &quot;application/pgp-encrypted&quot;
@@ -99,70 +107,85 @@ EOS
     encrypt from, to, payload, true
   end
 
-  def verified_ok? output, rc
-    output_lines = output.split(/\n/)
-
-    if output =~ /^gpg: (.* signature from .*$)/
-      if rc == 0
-        Chunk::CryptoNotice.new :valid, $1, output_lines
-      else
-        Chunk::CryptoNotice.new :invalid, $1, output_lines
+  def verified_ok? verify_result
+    valid = true
+    unknown = false
+    output_lines = []
+
+    verify_result.signatures.each do |signature|
+      output_lines.push(sig_output_lines(signature))
+      output_lines.flatten!
+      err_code = GPGME::gpgme_err_code(signature.status)
+      if err_code == GPGME::GPG_ERR_BAD_SIGNATURE
+        valid = false 
+      elsif err_code != GPGME::GPG_ERR_NO_ERROR
+        valid = false
+        unknown = true
       end
-    elsif output_lines.length == 0 &amp;&amp; rc == 0
-      # the message wasn't signed
+    end
+
+    if output_lines.length == 0
       Chunk::CryptoNotice.new :valid, &quot;Encrypted message wasn't signed&quot;, output_lines
+    elsif valid
+      Chunk::CryptoNotice.new(:valid, simplify_sig_line(verify_result.signatures[0].to_s), output_lines)
+    elsif !unknown
+      Chunk::CryptoNotice.new(:invalid, simplify_sig_line(verify_result.signatures[0].to_s), output_lines)
     else
       unknown_status output_lines
     end
   end
 
   def verify payload, signature, detached=true # both RubyMail::Message objects
-    return unknown_status(cant_find_binary) unless @cmd
+    return unknown_status(cant_find_gpgme) unless @gpgme_present
 
+    gpg_opts = {:protocol =&gt; GPGME::PROTOCOL_OpenPGP}
+    gpg_opts = HookManager.run(&quot;gpg-options&quot;, 
+                               {:operation =&gt; &quot;verify&quot;, :options =&gt; gpg_opts}) || gpg_opts
+    ctx = GPGME::Ctx.new(gpg_opts) 
+    sig_data = GPGME::Data.from_str signature.decode
     if detached
-      payload_fn = Tempfile.new &quot;redwood.payload&quot;
-      payload_fn.write format_payload(payload)
-      payload_fn.close
-    end
-
-    signature_fn = Tempfile.new &quot;redwood.signature&quot;
-    signature_fn.write signature.decode
-    signature_fn.close
-
-    if detached
-      output = run_gpg &quot;--verify #{signature_fn.path} #{payload_fn.path}&quot;
+      signed_text_data = GPGME::Data.from_str(format_payload(payload))
+      plain_data = nil
     else
-      output = run_gpg &quot;--verify #{signature_fn.path}&quot;
+      signed_text_data = nil
+      plain_data = GPGME::Data.empty
     end
-
-    self.verified_ok? output, $?
+    begin
+      ctx.verify(sig_data, signed_text_data, plain_data)
+    rescue GPGME::Error =&gt; exc
+      return unknown_status exc.message 
+    end
+    self.verified_ok? ctx.verify_result
   end
 
   ## returns decrypted_message, status, desc, lines
   def decrypt payload, armor=false # a RubyMail::Message object
-    return unknown_status(cant_find_binary) unless @cmd
-
-    payload_fn = Tempfile.new([&quot;redwood.payload&quot;, &quot;.asc&quot;])
-    payload_fn.write payload.to_s
-    payload_fn.close
-
-    output_fn = Tempfile.new &quot;redwood.output&quot;
-    output_fn.close
-
-    message = run_gpg &quot;--output #{output_fn.path} --skip-verify --yes --decrypt #{payload_fn.path}&quot;, :interactive =&gt; true
-
-    unless $?.success?
-      info &quot;Error while running gpg: #{message}&quot;
-      return Chunk::CryptoNotice.new(:invalid, &quot;This message could not be decrypted&quot;, message.split(&quot;\n&quot;))
+    return unknown_status(cant_find_gpgme) unless @gpgme_present
+
+    gpg_opts = {:protocol =&gt; GPGME::PROTOCOL_OpenPGP}
+    gpg_opts = HookManager.run(&quot;gpg-options&quot;, 
+                               {:operation =&gt; &quot;decrypt&quot;, :options =&gt; gpg_opts}) || gpg_opts
+    ctx = GPGME::Ctx.new(gpg_opts) 
+    cipher_data = GPGME::Data.from_str(format_payload(payload))
+    plain_data = GPGME::Data.empty
+    begin
+      ctx.decrypt_verify(cipher_data, plain_data)
+    rescue GPGME::Error =&gt; exc
+      info &quot;Error while running gpg: #{exc.message}&quot;
+      return Chunk::CryptoNotice.new(:invalid, &quot;This message could not be decrypted&quot;, exc.message)
     end
-
-    output = IO.read output_fn.path
+    sig = self.verified_ok? ctx.verify_result
+    plain_data.seek(0, IO::SEEK_SET)
+    output = plain_data.read
     output.force_encoding Encoding::ASCII_8BIT if output.respond_to? :force_encoding
 
+    ## TODO: test to see if it is still necessary to do a 2nd run if verify
+    ## fails.
+    #
     ## check for a valid signature in an extra run because gpg aborts if the
     ## signature cannot be verified (but it is still able to decrypt)
-    sigoutput = run_gpg &quot;#{payload_fn.path}&quot;
-    sig = self.verified_ok? sigoutput, $?
+    #sigoutput = run_gpg &quot;#{payload_fn.path}&quot;
+    #sig = self.old_verified_ok? sigoutput, $?
 
     if armor
       msg = RMail::Message.new
@@ -207,8 +230,8 @@ private
     Chunk::CryptoNotice.new :unknown, &quot;Unable to determine validity of cryptographic signature&quot;, lines
   end
 
-  def cant_find_binary
-    [&quot;Can't find gpg binary in path.&quot;]
+  def cant_find_gpgme
+    [&quot;Can't find gpgme gem.&quot;]
   end
 
   ## here's where we munge rmail output into the format that signed/encrypted
@@ -217,6 +240,28 @@ private
     payload.to_s.gsub(/(^|[^\r])\n/, &quot;\\1\r\n&quot;)
   end
 
+  # remove the hex key_id and info in ()
+  def simplify_sig_line sig_line
+    sig_line = sig_line.sub(/from [0-9A-F]{16} /, &quot;from &quot;)
+    sig_line.sub(/\(.+\) &lt;/, &quot;&lt;&quot;)
+  end
+
+  def sig_output_lines signature
+    time_line = &quot;Signature made &quot; + signature.timestamp.strftime(&quot;%a %d %b %Y %H:%M:%S %Z&quot;) +
+                &quot; using key ID &quot; + signature.fingerprint[-8..-1]
+    first_sig = signature.to_s.sub(/from [0-9A-F]{16} /, 'from &quot;') + '&quot;'
+    output_lines = [time_line, first_sig]
+
+    ctx = GPGME::Ctx.new
+    if from_key = ctx.get_key(signature.fingerprint)
+      if from_key.uids.length &gt; 1
+        aka_list = from_key.uids[1..-1]
+        aka_list.each { |aka| output_lines &lt;&lt; '                aka &quot;' + aka.uid + '&quot;' }
+      end
+    end
+    output_lines
+  end
+
   # logic is:
   # if    gpgkey set for this account, then use that
   # elsif only one account,            then leave blank so gpg default will be user
@@ -224,30 +269,14 @@ private
   def gen_sign_user_opts from
     account = AccountManager.account_for from
     if !account.gpgkey.nil?
-      opts = &quot;--local-user '#{account.gpgkey}'&quot;
+      opts = {:signers =&gt; account.gpgkey}
     elsif AccountManager.user_emails.length == 1
       # only one account
-      opts = &quot;&quot;
+      opts = {}
     else
-      opts = &quot;--local-user '#{from}'&quot; 
+      opts = {:signers =&gt; from}
     end
     opts
   end
-
-  def run_gpg args, opts={}
-    args = HookManager.run(&quot;gpg-args&quot;, { :args =&gt; args }) || args
-    cmd = &quot;LC_MESSAGES=C #{@cmd} #{args}&quot;
-    if opts[:interactive] &amp;&amp; BufferManager.instantiated?
-      output_fn = Tempfile.new &quot;redwood.output&quot;
-      output_fn.close
-      cmd += &quot; &gt; #{output_fn.path} 2&gt; /dev/null&quot;
-      debug &quot;crypto: running: #{cmd}&quot;
-      BufferManager.shell_out cmd
-      IO.read(output_fn.path) rescue &quot;can't read output&quot;
-    else
-      debug &quot;crypto: running: #{cmd}&quot;
-      `#{cmd} 2&gt; /dev/null`
-    end
-  end
 end
 end
-- 
1.7.1

</pre><pre>_______________________________________________
Sup-devel mailing list
Sup-devel@rubyforge.org
<a  rel="nofollow" href="http://rubyforge.org/mailman/listinfo/sup-devel">http://rubyforge.org/mailman/listinfo/sup-devel</a>
</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00766" href="msg00766.html">Re: [sup-devel] [PATCH] Converted crypto to use the gpgme gem</a></strong>
<ul><li><em>From:</em> Hamish D &lt;dmishd@gmail.com&gt;</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00723.html">[sup-devel] [issue126] exception at the first poll after a message	has been sent</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00766.html">Re: [sup-devel] [PATCH] Converted crypto to use the gpgme gem</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00620.html">Re: [sup-devel] [PATCH] 'u' in thread-view-mode copies URL to X	selection</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00766.html">Re: [sup-devel] [PATCH] Converted crypto to use the gpgme gem</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#00738"><strong>Date</strong></a></li>
<li><a href="threads.html#00738"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
