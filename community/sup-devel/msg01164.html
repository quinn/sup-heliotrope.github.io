<!-- MHonArc v2.6.18 -->
<!--X-Subject: Re: [sup&#45;devel] [PATCHv2] Saved Search Support -->
<!--X-From-R13: Sevp Eurezna <ulcreobyvfgNtznvy.pbz> -->
<!--X-Date: Tue, 19 Jan 2010 19:56:18 &#45;0800 (PST) -->
<!--X-Message-Id: 1263959248&#45;sup&#45;4163@changeling.local -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 1263858172&#45;sup&#45;547@changeling.local -->
<!--X-Reference: 1263920054&#45;sup&#45;9400@zyrg.net -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Re: [sup-devel] [PATCHv2] Saved Search Support</title>
<link rev="made" href="mailto:hyperbolist@gmail.com">
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg01224.html">Date Prev</a>][<a href="msg01208.html">Date Next</a>][<a href="msg01224.html">Thread Prev</a>][<a href="msg01208.html">Thread Next</a>][<a href="maillist.html#01164">Date Index</a>][<a href="threads.html#01164">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: [sup-devel] [PATCHv2] Saved Search Support</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Rich Lane &lt;<a href="mailto:rlane%40club.cc.cmu.edu">rlane@club.cc.cmu.edu</a>&gt;</li>
<li><em>Subject</em>: Re: [sup-devel] [PATCHv2] Saved Search Support</li>
<li><em>From</em>: Eric Sherman &lt;<a href="mailto:hyperbolist%40gmail.com">hyperbolist@gmail.com</a>&gt;</li>
<li><em>Date</em>: Tue, 19 Jan 2010 22:48:50 -0500</li>
<li><em>Authentication-results</em>: mx.google.com; spf=pass (google.com: domain of <a href="mailto:sup-devel-bounces%40rubyforge.org">sup-devel-bounces@rubyforge.org</a> designates 205.234.109.19 as permitted sender) smtp.mail=<a href="mailto:sup-devel-bounces%40rubyforge.org">sup-devel-bounces@rubyforge.org</a>; dkim=neutral (body hash did not verify) header.i=@gmail.com</li>
<li><em>Cc</em>: sup-devel &lt;<a href="mailto:sup-devel%40rubyforge.org">sup-devel@rubyforge.org</a>&gt;</li>
<li><em>Delivered-to</em>: <a href="mailto:eg%40gaute.vetsj.com">eg@gaute.vetsj.com</a></li>
<li><em>Delivered-to</em>: <a href="mailto:sup-devel%40rubyforge.org">sup-devel@rubyforge.org</a></li>
<li><em>Dkim-signature</em>: v=1; a=rsa-sha256; c=relaxed/relaxed; d=gmail.com; s=gamma;	h=domainkey-signature:received:received:content-type:cc:subject:from	:to:in-reply-to:references:date:message-id:user-agent	:content-transfer-encoding;	bh=06Lr/77JbC8bZGsOy3mQsUAhXA7zp5Hy47Q5l9QeVhM=;	b=fybLiYTphANogNy5e5QybCoHYu5MDfKznJJAjDqnJv3X14+czkgqwjf9QEXkmB5MXK	HyxbbP4LxdhxnXL4A4mllfr5iqW6z2sq1O8+SOQNSrdAbNPdpoyyZM6BLx0X2Fdl5OTK	nlwmFDDhBd1neR4acq6hIi0DTt8sMSTHthqpc=</li>
<li><em>Domainkey-signature</em>: a=rsa-sha1; c=nofws; d=gmail.com; s=gamma;	h=content-type:cc:subject:from:to:in-reply-to:references:date	:message-id:user-agent:content-transfer-encoding;	b=jarb9C7nrLVGWz+zzTH3Y89pvxmlN/KF3Tdl06POSaNhzAm5ILBh89lbBrhiWAu1Ct	0DEEJ5WFRuO1NYHRquYE8MMrwivTXto8SI6UHv3oD7k+dXPt+5AyvcyMCF92DpNW7ySw	SRZPRYxrZNENscRRdiplz7FhuSHBO++bl1D9c=</li>
<li><em>In-reply-to</em>: &lt;<a href="msg01354.html">1263920054-sup-9400@zyrg.net</a>&gt;</li>
<li><em>List-archive</em>: &lt;<a href="http://rubyforge.org/pipermail/sup-devel">http://rubyforge.org/pipermail/sup-devel</a>&gt;</li>
<li><em>List-help</em>: &lt;<a href="mailto:sup-devel-request@rubyforge.org?subject=help">mailto:sup-devel-request@rubyforge.org?subject=help</a>&gt;</li>
<li><em>List-id</em>: Sup developer discussion &lt;sup-devel.rubyforge.org&gt;</li>
<li><em>List-post</em>: &lt;<a href="mailto:sup-devel@rubyforge.org">mailto:sup-devel@rubyforge.org</a>&gt;</li>
<li><em>List-subscribe</em>: &lt;<a href="http://rubyforge.org/mailman/listinfo/sup-devel">http://rubyforge.org/mailman/listinfo/sup-devel</a>&gt;,	&lt;<a href="mailto:sup-devel-request@rubyforge.org?subject=subscribe">mailto:sup-devel-request@rubyforge.org?subject=subscribe</a>&gt;</li>
<li><em>List-unsubscribe</em>: &lt;<a href="http://rubyforge.org/mailman/options/sup-devel">http://rubyforge.org/mailman/options/sup-devel</a>&gt;,	&lt;<a href="mailto:sup-devel-request@rubyforge.org?subject=unsubscribe">mailto:sup-devel-request@rubyforge.org?subject=unsubscribe</a>&gt;</li>
<li><em>References</em>: &lt;1263858172-sup-547@changeling.local&gt;	&lt;<a href="msg01354.html">1263920054-sup-9400@zyrg.net</a>&gt;</li>
<li><em>Reply-to</em>: Sup developer discussion &lt;<a href="mailto:sup-devel%40rubyforge.org">sup-devel@rubyforge.org</a>&gt;</li>
<li><em>Sender</em>: <a href="mailto:sup-devel-bounces%40rubyforge.org">sup-devel-bounces@rubyforge.org</a></li>
<li><em>User-agent</em>: Sup/git</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>Start an index search with a \ backslash and press enter to get a list
of searches that were previously saved from search-results-mode with %
percent or added from search-list-mode directly.  Saved searches may be
used in other searches by enclosing their names in {} curly braces.
Search names may contain letters, numbers, underscores and dashes.

New Key Bindings
global
  \&lt;CR&gt; open search-list-mode
search-list-mode
  X     Delete selected search
  r     Rename selected search
  e     Edit selected search
  a     Add new search
search-results-mode
  %     Save search

New Hooks
search-list-filter
search-list-format

Search String Expansion
Include saved searches in other searches by enclosing their names in {}
curly braces.  The name and enclosing braces are replaced by the actual
search string and enclosing () parens.

    low_traffic: has:foo OR has:bar
    a_slow_week: {low_traffic} AND after:(7 days ago)

{a_slow_week} expands to &quot;(has:foo OR has:bar) AND after:(7 days ago)&quot;
and may be used in a global search, a refinement or another saved
search.  A search including the undefined {baz} will fail. To search for
a literal string enclosed in curly braces, escape the curly braces with
\ backslash: &quot;\{baz\}&quot;.

There is no nesting limit and searches are always expanded completely
before they are turned into proper queries for the index.

Save File Format
Searches are read from ~/.sup/searches.txt on startup and saved at exit.
The format is &quot;name: search_string&quot;.  Here's a silly example:

    core: {me} AND NOT {crap} AND NOT {weak}
    crap: is:leadlogger OR is:alert OR is:rzp
    me: to:me OR from:me
    recent: after:(14 days ago)
    top: {core} AND {recent}
    weak: is:feed OR is:list OR is:ham
---
 bin/sup                              |   11 ++-
 lib/sup.rb                           |    5 +
 lib/sup/modes/search-list-mode.rb    |  188 ++++++++++++++++++++++++++++++++++
 lib/sup/modes/search-results-mode.rb |   23 ++++-
 lib/sup/search.rb                    |   72 +++++++++++++
 5 files changed, 294 insertions(+), 5 deletions(-)
 create mode 100644 lib/sup/modes/search-list-mode.rb
 create mode 100644 lib/sup/search.rb

diff --git a/bin/sup b/bin/sup
index 8bf640b..fb19795 100755
--- a/bin/sup
+++ b/bin/sup
@@ -303,9 +303,14 @@ begin
       b, new = bm.spawn_unless_exists(&quot;Contact List&quot;) { ContactListMode.new }
       b.mode.load_in_background if new
     when :search
-      query = BufferManager.ask :search, &quot;search all messages: &quot;
-      next unless query &amp;&amp; query !~ /^\s*$/
-      SearchResultsMode.spawn_from_query query
+      query = BufferManager.ask :search, &quot;Search all messages (enter for saved searches): &quot;
+      unless query.nil?
+        if query.empty?
+          bm.spawn_unless_exists(&quot;Saved searches&quot;) { SearchListMode.new }
+        else
+          SearchResultsMode.spawn_from_query query
+        end
+      end
     when :search_unread
       SearchResultsMode.spawn_from_query &quot;is:unread&quot;
     when :list_labels
diff --git a/lib/sup.rb b/lib/sup.rb
index e03a35d..b9dc749 100644
--- a/lib/sup.rb
+++ b/lib/sup.rb
@@ -50,6 +50,7 @@ module Redwood
   LOCK_FN    = File.join(BASE_DIR, &quot;lock&quot;)
   SUICIDE_FN = File.join(BASE_DIR, &quot;please-kill-yourself&quot;)
   HOOK_DIR   = File.join(BASE_DIR, &quot;hooks&quot;)
+  SEARCH_FN  = File.join(BASE_DIR, &quot;searches.txt&quot;)
 
   YAML_DOMAIN = &quot;masanjin.net&quot;
   YAML_DATE = &quot;2006-10-01&quot;
@@ -131,12 +132,14 @@ module Redwood
     Redwood::CryptoManager.init
     Redwood::UndoManager.init
     Redwood::SourceManager.init
+    Redwood::SearchManager.init Redwood::SEARCH_FN
   end
 
   def finish
     Redwood::LabelManager.save if Redwood::LabelManager.instantiated?
     Redwood::ContactManager.save if Redwood::ContactManager.instantiated?
     Redwood::BufferManager.deinstantiate! if Redwood::BufferManager.instantiated?
+    Redwood::SearchManager.save if Redwood::SearchManager.instantiated?
   end
 
   ## not really a good place for this, so I'll just dump it here.
@@ -341,6 +344,8 @@ require &quot;sup/modes/file-browser-mode&quot;
 require &quot;sup/modes/completion-mode&quot;
 require &quot;sup/modes/console-mode&quot;
 require &quot;sup/sent&quot;
+require &quot;sup/search&quot;
+require &quot;sup/modes/search-list-mode&quot;
 
 $:.each do |base|
   d = File.join base, &quot;sup/share/modes/&quot;
diff --git a/lib/sup/modes/search-list-mode.rb b/lib/sup/modes/search-list-mode.rb
new file mode 100644
index 0000000..076c3d9
--- /dev/null
+++ b/lib/sup/modes/search-list-mode.rb
@@ -0,0 +1,188 @@
+module Redwood
+
+class SearchListMode &lt; LineCursorMode
+  register_keymap do |k|
+    k.add :select_search, &quot;Open search results&quot;, :enter
+    k.add :reload, &quot;Discard saved search list and reload&quot;, '@'
+    k.add :jump_to_next_new, &quot;Jump to next new thread&quot;, :tab
+    k.add :toggle_show_unread_only, &quot;Toggle between showing all saved searches and those with unread mail&quot;, 'u'
+    k.add :delete_selected_search, &quot;Delete selected search&quot;, &quot;X&quot;
+    k.add :rename_selected_search, &quot;Rename selected search&quot;, &quot;r&quot;
+    k.add :edit_selected_search, &quot;Edit selected search&quot;, &quot;e&quot;
+    k.add :add_new_search, &quot;Add new search&quot;, &quot;a&quot;
+  end
+
+  HookManager.register &quot;search-list-filter&quot;, &lt;&lt;EOS
+Filter the search list, typically to sort.
+Variables:
+  counted: an array of counted searches.
+Return value:
+  An array of counted searches with sort_by output structure.
+EOS
+
+  HookManager.register &quot;search-list-format&quot;, &lt;&lt;EOS
+Create the sprintf format string for search-list-mode.
+Variables:
+  n_width: the maximum search name width
+  tmax: the maximum total message count
+  umax: the maximum unread message count
+  s_width: the maximum search string width
+Return value:
+  A format string for sprintf
+EOS
+
+  def initialize
+    @searches = []
+    @text = []
+    @unread_only = false
+    super
+    UpdateManager.register self
+    regen_text
+  end
+
+  def cleanup
+    UpdateManager.unregister self
+    super
+  end
+
+  def lines; @text.length end
+  def [] i; @text[i] end
+
+  def jump_to_next_new
+    n = ((curpos + 1) ... lines).find { |i| @searches[i][1] &gt; 0 } || (0 ... curpos).find { |i| @searches[i][1] &gt; 0 }
+    if n
+      ## jump there if necessary
+      jump_to_line n unless n &gt;= topline &amp;&amp; n &lt; botline
+      set_cursor_pos n
+    else
+      BufferManager.flash &quot;No saved searches with unread messages.&quot;
+    end
+  end
+
+  def focus
+    reload # make sure unread message counts are up-to-date
+  end
+
+  def handle_added_update sender, m
+    reload
+  end
+
+protected
+
+  def toggle_show_unread_only
+    @unread_only = !@unread_only
+    reload
+  end
+
+  def reload
+    regen_text
+    buffer.mark_dirty if buffer
+  end
+
+  def regen_text
+    @text = []
+    searches = SearchManager.all_searches
+
+    counted = searches.map do |name|
+      search_string = SearchManager.search_string_for name
+      expanded_search_string= SearchManager.expand search_string
+      if expanded_search_string
+        query = Index.parse_query expanded_search_string
+        total = Index.num_results_for :qobj =&gt; query[:qobj]
+        unread = Index.num_results_for :qobj =&gt; query[:qobj], :label =&gt; :unread
+      else
+        total = 0
+        unread = 0
+      end
+      [name, search_string, total, unread]
+    end
+
+    if HookManager.enabled? &quot;search-list-filter&quot;
+      counts = HookManager.run &quot;search-list-filter&quot;, :counted =&gt; counted
+    else
+      counts = counted.sort_by { |n, s, t, u| n.downcase }
+    end
+
+    n_width = counts.max_of { |n, s, t, u| n.length }
+    tmax    = counts.max_of { |n, s, t, u| t }
+    umax    = counts.max_of { |n, s, t, u| u }
+    s_width = counts.max_of { |n, s, t, u| s.length }
+
+    if @unread_only
+      counts.delete_if { | n, s, t, u | u == 0 }
+    end
+
+    @searches = []
+    counts.each do |name, search_string, total, unread|
+      fmt = HookManager.run &quot;search-list-format&quot;, :n_width =&gt; n_width, :tmax =&gt; tmax, :umax =&gt; umax, :s_width =&gt; s_width
+      if !fmt
+        fmt = &quot;%#{n_width + 1}s %5d %s, %5d unread: %s&quot;
+      end
+      @text &lt;&lt; [[(unread == 0 ? :labellist_old_color : :labellist_new_color),
+          sprintf(fmt, name, total, total == 1 ? &quot; message&quot; : &quot;messages&quot;, unread, search_string)]]
+      @searches &lt;&lt; [name, unread]
+    end
+
+    BufferManager.flash &quot;No saved searches with unread messages!&quot; if counts.empty? &amp;&amp; @unread_only
+  end
+
+  def select_search
+    name, num_unread = @searches[curpos]
+    return unless name
+    SearchResultsMode.spawn_from_query SearchManager.search_string_for(name)
+  end
+
+  def delete_selected_search
+    name, num_unread = @searches[curpos]
+    return unless name
+    reload if SearchManager.delete name
+  end
+
+  def rename_selected_search
+    old_name, num_unread = @searches[curpos]
+    return unless old_name
+    new_name = BufferManager.ask :save_search, &quot;Rename this saved search: &quot;, old_name
+    return unless new_name &amp;&amp; new_name !~ /^\s*$/ &amp;&amp; new_name != old_name
+    new_name.strip!
+    unless SearchManager.valid_name? new_name
+      BufferManager.flash &quot;Not renamed: &quot; + SearchManager.name_format_hint
+      return
+    end
+    if SearchManager.all_searches.include? new_name
+      BufferManager.flash &quot;Not renamed: \&quot;#{new_name}\&quot; already exists&quot;
+      return
+    end
+    reload if SearchManager.rename old_name, new_name
+    set_cursor_pos @searches.index([new_name, num_unread])||curpos
+  end
+
+  def edit_selected_search
+    name, num_unread = @searches[curpos]
+    return unless name
+    old_search_string = SearchManager.search_string_for name
+    new_search_string = BufferManager.ask :search, &quot;Edit this saved search: &quot;, (old_search_string + &quot; &quot;)
+    return unless new_search_string &amp;&amp; new_search_string !~ /^\s*$/ &amp;&amp; new_search_string != old_search_string
+    reload if SearchManager.edit name, new_search_string.strip
+    set_cursor_pos @searches.index([name, num_unread])||curpos
+  end
+
+  def add_new_search
+    search_string = BufferManager.ask :search, &quot;New search: &quot;
+    return unless search_string &amp;&amp; search_string !~ /^\s*$/
+    name = BufferManager.ask :save_search, &quot;Name this search: &quot;
+    return unless name &amp;&amp; name !~ /^\s*$/
+    name.strip!
+    unless SearchManager.valid_name? name
+      BufferManager.flash &quot;Not saved: &quot; + SearchManager.name_format_hint
+      return
+    end
+    if SearchManager.all_searches.include? name
+      BufferManager.flash &quot;Not saved: \&quot;#{name}\&quot; already exists&quot;
+      return
+    end
+    reload if SearchManager.add name, search_string.strip
+    set_cursor_pos @searches.index(@searches.assoc(name))||curpos
+  end
+end
+
+end
diff --git a/lib/sup/modes/search-results-mode.rb b/lib/sup/modes/search-results-mode.rb
index 121e817..14d42b5 100644
--- a/lib/sup/modes/search-results-mode.rb
+++ b/lib/sup/modes/search-results-mode.rb
@@ -8,14 +8,30 @@ class SearchResultsMode &lt; ThreadIndexMode
 
   register_keymap do |k|
     k.add :refine_search, &quot;Refine search&quot;, '|'
+    k.add :save_search, &quot;Save search&quot;, '%'
   end
 
   def refine_search
-    text = BufferManager.ask :search, &quot;refine query: &quot;, (@query[:text] + &quot; &quot;)
+    text = BufferManager.ask :search, &quot;refine query: &quot;, (@query[:unexpanded_text] + &quot; &quot;)
     return unless text &amp;&amp; text !~ /^\s*$/
     SearchResultsMode.spawn_from_query text
   end
 
+  def save_search
+    name = BufferManager.ask :save_search, &quot;Name this search: &quot;
+    return unless name &amp;&amp; name !~ /^\s*$/
+    name.strip!
+    unless SearchManager.valid_name? name
+      BufferManager.flash &quot;Not saved: &quot; + SearchManager.name_format_hint
+      return
+    end
+    if SearchManager.all_searches.include? name
+      BufferManager.flash &quot;Not saved: \&quot;#{name}\&quot; already exists&quot;
+      return
+    end
+    BufferManager.flash &quot;Search saved as \&quot;#{name}\&quot;&quot; if SearchManager.add name, @query[:unexpanded_text].strip
+  end
+
   ## a proper is_relevant? method requires some way of asking ferret
   ## if an in-memory object satisfies a query. i'm not sure how to do
   ## that yet. in the worst case i can make an in-memory index, add
@@ -24,8 +40,11 @@ class SearchResultsMode &lt; ThreadIndexMode
 
   def self.spawn_from_query text
     begin
-      query = Index.parse_query(text)
+      expanded_text = SearchManager.expand text
+      return unless expanded_text
+      query = Index.parse_query expanded_text
       return unless query
+      query[:unexpanded_text] = text
       short_text = text.length &lt; 20 ? text : text[0 ... 20] + &quot;...&quot;
       mode = SearchResultsMode.new query
       BufferManager.spawn &quot;search: \&quot;#{short_text}\&quot;&quot;, mode
diff --git a/lib/sup/search.rb b/lib/sup/search.rb
new file mode 100644
index 0000000..799ca89
--- /dev/null
+++ b/lib/sup/search.rb
@@ -0,0 +1,72 @@
+module Redwood
+
+class SearchManager
+  include Singleton
+
+  def initialize fn
+    @fn = fn
+    @searches = {}
+    if File.exists? fn
+      IO.foreach(fn) do |l|
+        l =~ /^([^:]*): (.*)$/ or raise &quot;can't parse #{fn} line #{l.inspect}&quot;
+        @searches[$1] = $2
+      end
+    end
+    @modified = false
+  end
+
+  def all_searches; return @searches.keys.sort; end
+  def search_string_for name; return @searches[name]; end
+  def valid_name? name; name =~ /^[\w-]+$/; end
+  def name_format_hint; &quot;letters, numbers, underscores and dashes only&quot;; end
+
+  def add name, search_string
+    return unless valid_name? name
+    @searches[name] = search_string
+    @modified = true
+  end
+
+  def rename old, new
+    return unless @searches.has_key? old
+    search_string = @searches[old]
+    delete old if add new, search_string
+  end
+
+  def edit name, search_string
+    return unless @searches.has_key? name
+    @searches[name] = search_string
+    @modified = true
+  end
+
+  def delete name
+    return unless @searches.has_key? name
+    @searches.delete name
+    @modified = true
+  end
+
+  def expand search_string
+    expanded = search_string.dup
+    until (matches = expanded.scan(/\{([\w-]+)\}/).flatten).empty?
+      if !(unknown = matches - @searches.keys).empty?
+        error_message = &quot;Unknown \&quot;#{unknown.join('&quot;, &quot;')}\&quot; when expanding \&quot;#{search_string}\&quot;&quot;
+      elsif expanded.size &gt;= 2048
+        error_message = &quot;Check for infinite recursion in \&quot;#{search_string}\&quot;&quot;
+      end
+      if error_message
+        warn error_message
+        BufferManager.flash error_message
+        return false
+      end
+      matches.each { |n| expanded.gsub! &quot;{#{n}}&quot;, &quot;(#{@searches[n]})&quot; if @searches.has_key? n }
+    end
+    return expanded
+  end
+
+  def save
+    return unless @modified
+    File.open(@fn, &quot;w&quot;) { |f| @searches.sort.each { |(n, s)| f.puts &quot;#{n}: #{s}&quot; } }
+    @modified = false
+  end
+end
+
+end
-- 
1.6.6
_______________________________________________
Sup-devel mailing list
Sup-devel@rubyforge.org
<a  rel="nofollow" href="http://rubyforge.org/mailman/listinfo/sup-devel">http://rubyforge.org/mailman/listinfo/sup-devel</a>
</pre>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="01208" href="msg01208.html">Re: [sup-devel] [PATCHv2] Saved Search Support</a></strong>
<ul><li><em>From:</em> Rich Lane &lt;rlane@club.cc.cmu.edu&gt;</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="01361" href="msg01361.html">[sup-devel] [PATCH] Saved Search Support</a></strong>
<ul><li><em>From:</em> Eric Sherman &lt;hyperbolist@gmail.com&gt;</li></ul></li>
<li><strong><a name="01354" href="msg01354.html">Re: [sup-devel] [PATCH] Saved Search Support</a></strong>
<ul><li><em>From:</em> Rich Lane &lt;rlane@club.cc.cmu.edu&gt;</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg01224.html">Re: [sup-devel] [PATCH] Saved Search Support</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg01208.html">Re: [sup-devel] [PATCHv2] Saved Search Support</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg01224.html">Re: [sup-devel] [PATCH] Saved Search Support</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg01208.html">Re: [sup-devel] [PATCHv2] Saved Search Support</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#01164"><strong>Date</strong></a></li>
<li><a href="threads.html#01164"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
