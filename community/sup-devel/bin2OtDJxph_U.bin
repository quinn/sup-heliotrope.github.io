From b77ace80b888896f281b3c39e8a9f4f315813a35 Mon Sep 17 00:00:00 2001
From: Michael Stapelberg <michael@stapelberg.de>
Date: Tue, 9 Mar 2010 17:40:48 +0100
Subject: [PATCH] Implement inline GPG
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The SIG_PATTERN had to be changed because GPG, when clearsigning (which
is what happens when you send inline GPG messages), kind of escapes
lines beginning with dashes (so that the -----BEGIN PGP MESSAGE-----
lines donâ€™t get messed up). Therefore, signatures, starting with "-- "
will be escaped as "- -- ". The manpage of GPG states that the process
of clearsigning is not reversible. Thus, there is no method in GPG to
get the original message.
---
 lib/sup/crypto.rb  |   62 ++++++++++++++++++++++++++++++++-------------------
 lib/sup/message.rb |   34 +++++++++++++++++++++++++++-
 2 files changed, 72 insertions(+), 24 deletions(-)

diff --git a/lib/sup/crypto.rb b/lib/sup/crypto.rb
index 5ece6d9..abbcb98 100644
--- a/lib/sup/crypto.rb
+++ b/lib/sup/crypto.rb
@@ -97,18 +97,24 @@ EOS
     encrypt from, to, payload, true
   end
 
-  def verify payload, signature # both RubyMail::Message objects
+  def verify payload, signature, detached=true # both RubyMail::Message objects
     return unknown_status(cant_find_binary) unless @cmd
 
-    payload_fn = Tempfile.new "redwood.payload"
-    payload_fn.write format_payload(payload)
-    payload_fn.close
+    if detached
+      payload_fn = Tempfile.new "redwood.payload"
+      payload_fn.write format_payload(payload)
+      payload_fn.close
+    end
 
     signature_fn = Tempfile.new "redwood.signature"
     signature_fn.write signature.decode
     signature_fn.close
 
-    output = run_gpg "--verify #{signature_fn.path} #{payload_fn.path}"
+    if detached
+      output = run_gpg "--verify #{signature_fn.path} #{payload_fn.path}"
+    else
+      output = run_gpg "--verify #{signature_fn.path}"
+    end
     output_lines = output.split(/\n/)
 
     if output =~ /^gpg: (.* signature from .*$)/
@@ -123,7 +129,7 @@ EOS
   end
 
   ## returns decrypted_message, status, desc, lines
-  def decrypt payload # a RubyMail::Message object
+  def decrypt payload, armor=false # a RubyMail::Message object
     return unknown_status(cant_find_binary) unless @cmd
 
     payload_fn = Tempfile.new "redwood.payload"
@@ -153,24 +159,34 @@ EOS
       Chunk::CryptoNotice.new :invalid, $1, message.split("\n")
     end
 
-    # This is gross. This decrypted payload could very well be a multipart
-    # element itself, as opposed to a simple payload. For example, a
-    # multipart/signed element, like those generated by Mutt when encrypting
-    # and signing a message (instead of just clearsigning the body).
-    # Supposedly, decrypted_payload being a multipart element ought to work
-    # out nicely because Message::multipart_encrypted_to_chunks() runs the
-    # decrypted message through message_to_chunks() again to get any
-    # children. However, it does not work as intended because these inner
-    # payloads need not carry a MIME-Version header, yet they are fed to
-    # RMail as a top-level message, for which the MIME-Version header is
-    # required. This causes for the part not to be detected as multipart,
-    # hence being shown as an attachment. If we detect this is happening,
-    # we force the decrypted payload to be interpreted as MIME.
-    msg = RMail::Parser.read output
-    if msg.header.content_type =~ %r{^multipart/} && !msg.multipart?
-      output = "MIME-Version: 1.0\n" + output
-      output.force_encoding Encoding::ASCII_8BIT if output.respond_to? :force_encoding
+    if armor
+      msg = RMail::Message.new
+      # Look for Charset, they are put before the base64 crypted part
+      charsets = payload.body.split("\n").grep(/^Charset:/)
+      if !charsets.empty? and charsets[0] =~ /^Charset: (.+)$/
+        output = Iconv.easy_decode($encoding, $1, output)
+      end
+      msg.body = output
+    else
+      # This is gross. This decrypted payload could very well be a multipart
+      # element itself, as opposed to a simple payload. For example, a
+      # multipart/signed element, like those generated by Mutt when encrypting
+      # and signing a message (instead of just clearsigning the body).
+      # Supposedly, decrypted_payload being a multipart element ought to work
+      # out nicely because Message::multipart_encrypted_to_chunks() runs the
+      # decrypted message through message_to_chunks() again to get any
+      # children. However, it does not work as intended because these inner
+      # payloads need not carry a MIME-Version header, yet they are fed to
+      # RMail as a top-level message, for which the MIME-Version header is
+      # required. This causes for the part not to be detected as multipart,
+      # hence being shown as an attachment. If we detect this is happening,
+      # we force the decrypted payload to be interpreted as MIME.
       msg = RMail::Parser.read output
+      if msg.header.content_type =~ %r{^multipart/} && !msg.multipart?
+        output = "MIME-Version: 1.0\n" + output
+        output.force_encoding Encoding::ASCII_8BIT if output.respond_to? :force_encoding
+        msg = RMail::Parser.read output
+      end
     end
     notice = Chunk::CryptoNotice.new :valid, "This message has been decrypted for display"
     [notice, sig, msg]
diff --git a/lib/sup/message.rb b/lib/sup/message.rb
index ebc73fc..ef87218 100644
--- a/lib/sup/message.rb
+++ b/lib/sup/message.rb
@@ -26,7 +26,7 @@ class Message
 
   QUOTE_PATTERN = /^\s{0,4}[>|\}]/
   BLOCK_QUOTE_PATTERN = /^-----\s*Original Message\s*----+$/
-  SIG_PATTERN = /(^-- ?$)|(^\s*----------+\s*$)|(^\s*_________+\s*$)|(^\s*--~--~-)|(^\s*--\+\+\*\*==)/
+  SIG_PATTERN = /(^(- )*-- ?$)|(^\s*----------+\s*$)|(^\s*_________+\s*$)|(^\s*--~--~-)|(^\s*--\+\+\*\*==)/
 
   MAX_SIG_DISTANCE = 15 # lines from the end
   DEFAULT_SUBJECT = ""
@@ -512,6 +512,38 @@ private
         ## this ensures that the body is normalized to avoid non-displayable
         ## characters
         body = Iconv.easy_decode($encoding, m.charset || $encoding, m.decode) if m.body
+        lines = body.split("\n")
+
+        ## Check for inline-PGP
+        msg_start = "^-----BEGIN PGP SIGNED MESSAGE-----$"
+        msg_end = "^-----END PGP SIGNED MESSAGE-----$"
+        gpg = lines.select { |l| true if l =~ /#{msg_start}/ .. l =~ /#{msg_end}/ }
+        if !gpg.empty?
+          msg = RMail::Message.new
+          msg.body = gpg.join("\n")
+
+          sig_start = "^-----BEGIN PGP SIGNATURE-----$"
+          sig = lines.select { |l| true if l =~ /#{msg_start}/ .. l =~ /#{sig_start}/ }
+          payload = RMail::Message.new
+          payload.body = sig[1, sig.count-2].join("\n")
+          return [CryptoManager.verify(nil, msg, false), message_to_chunks(payload)].flatten.compact
+        end
+
+        msg_start = "^-----BEGIN PGP MESSAGE-----$"
+        msg_end = "^-----END PGP MESSAGE-----$"
+        gpg = lines.select { |l| true if l =~ /#{msg_start}/ .. l =~ /#{msg_end}/ }
+        if !gpg.empty?
+          msg = RMail::Message.new
+          msg.body = gpg.join("\n")
+          notice, sig, decryptedm = CryptoManager.decrypt msg, true
+          if decryptedm # managed to decrypt
+            children = message_to_chunks(decryptedm, true)
+            return [notice, sig].compact + children
+          else
+            return [notice]
+          end
+        end
+
         text_to_chunks((body || "").normalize_whitespace.split("\n"), encrypted)
       end
     end
-- 
1.6.5

